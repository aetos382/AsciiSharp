# Feature Specification: AsciiDoc パーサー

**Feature Branch**: `001-asciidoc-parser`
**Created**: 2026-01-18
**Status**: Draft
**Input**: User description: "AsciiDoctor パーサーを作成します。AsciiDoc の構文については submodules/asciidoc-lang 下を参照します。インタラクティブなエディタの基盤となるのに十分な能力とパフォーマンスを持ち、構文エラーがあっても正常な部分は最大限に解析します。空白やコメントも含め、構文木から元のテキストを完全に再現できるようにします。構文木は Immutable にし、既存の構文木に変更を加える場合は、新しい構文木を作成します。"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 基本的な AsciiDoc 文書の解析 (Priority: P1)

ユーザーは、セクションと段落を含む AsciiDoc 文書をパーサーに入力し、正しい構文木を取得する。構文木は元のテキストを完全に再現可能である。

**Why this priority**: これはパーサーの最も基本的な機能であり、他のすべての機能の土台となる。最小限の実用可能な製品を提供するために最優先で実装する必要がある。

**Independent Test**: 単一の AsciiDoc 文書を解析し、構文木から元のテキストを再構築することで、ラウンドトリップ検証ができる。

**Acceptance Scenarios**:

1. **Given** 有効な AsciiDoc 文書（セクションタイトル、段落）、**When** パーサーで解析する、**Then** 正しい階層構造を持つ構文木が生成され、元のテキストが完全に再現可能である
2. **Given** ドキュメントヘッダー（タイトル、著者行）を含む AsciiDoc 文書、**When** パーサーで解析する、**Then** ヘッダー情報が正しく解析される
3. **Given** 空白行で区切られた複数のブロック、**When** パーサーで解析する、**Then** 各ブロックが独立したノードとして認識され、空白行も構文木に保持される

**注**: リスト、区切りブロック、属性エントリは後続イテレーションで実装

---

### User Story 2 - エラー耐性解析 (Priority: P1)

ユーザーは、構文エラーを含む AsciiDoc 文書を解析しても、正常な部分は最大限に解析され、エディタで有用な情報を表示できる。

**Why this priority**: インタラクティブエディタでは、ユーザーが入力中の不完全な文書を常に解析する必要がある。エラー回復なしでは実用的なエディタ体験が提供できない。

**Independent Test**: 意図的に構文エラーを含む文書を解析し、エラー部分が特定され、正常部分が正しく解析されることを検証できる。

**Acceptance Scenarios**:

1. **Given** セクションタイトルのマーカーが不完全な AsciiDoc 文書、**When** パーサーで解析する、**Then** エラーノードが作成され、他の正常な部分は正しく解析される
2. **Given** 閉じられていないブロック区切りがある AsciiDoc 文書、**When** パーサーで解析する、**Then** 未閉のブロックがエラーとして記録され、後続の内容は最善の推測で解析される
3. **Given** 複数のエラーを含む AsciiDoc 文書、**When** パーサーで解析する、**Then** すべてのエラー位置が報告され、各エラー間の正常な部分は独立して解析される

---

### User Story 3 - リンクの解析 (Priority: P2)

ユーザーは、URL リンクを含むテキストを解析し、リンクの位置とターゲットを正確に把握できる。

**Why this priority**: リンクはエディタでのクリック可能な要素として重要である。MVP スコープでは書式マークアップ（太字、斜体等）やマクロは対象外とする。

**Independent Test**: URL リンクを含む段落を解析し、リンクの位置とターゲットが正確に識別されることを検証できる。

**Acceptance Scenarios**:

1. **Given** URL リンク（https://example.com）を含む段落、**When** パーサーで解析する、**Then** リンクの開始位置、終了位置、ターゲット URL が構文木に記録される
2. **Given** 表示テキスト付きリンク（https://example.com[Example]）を含む段落、**When** パーサーで解析する、**Then** リンクのターゲットと表示テキストが正しく解析される
3. **Given** 複数のリンクを含む段落、**When** パーサーで解析する、**Then** 各リンクが独立したノードとして正しく解析される

**注**: 太字、斜体、等幅などの書式マークアップ、マクロ、属性参照は後続イテレーションで実装

---

### User Story 4 - 構文木の不変性とクエリ (Priority: P2)

開発者は、構文木を変更せずにクエリを行い、必要に応じて元の構文木を保持したまま新しい構文木を作成できる。

**Why this priority**: 不変性はエディタの undo/redo 機能、並行処理、キャッシングにおいて重要である。基本的な解析機能の後に実装可能。

**Independent Test**: 構文木に対して変更操作を行い、元の構文木が変更されず、新しい構文木が正しい変更を反映していることを検証できる。

**Acceptance Scenarios**:

1. **Given** 解析済みの構文木、**When** ノードを追加・削除・変更する操作を行う、**Then** 元の構文木は変更されず、変更を反映した新しい構文木が返される
2. **Given** 解析済みの構文木、**When** 特定の種類のノードをすべて検索するクエリを行う、**Then** 一致するノードのコレクションが返され、構文木は変更されない
3. **Given** 解析済みの構文木と、その構文木への参照を保持するコンポーネント、**When** 別のコンポーネントが構文木を「変更」する、**Then** 元の参照が指す構文木は影響を受けない

---

### User Story 5 - 増分解析 (Priority: P3)

ユーザーがエディタで文書の一部を編集したとき、パーサーは変更された部分のみを再解析し、変更されていない部分の解析結果を再利用する。

**Why this priority**: 大きな文書を編集する際のパフォーマンスを大幅に向上させる高度な機能。基本的な解析とエラー回復が安定してから実装する。

**Independent Test**: 大きな文書の一部を変更し、再解析時間が文書全体の解析時間より大幅に短いことを検証できる。

**Acceptance Scenarios**:

1. **Given** 1000行の AsciiDoc 文書と既存の構文木、**When** 10行目のみを編集する、**Then** 10行目を含むブロックのみが再解析され、他のブロックは再利用される
2. **Given** 複数のセクションを持つ文書、**When** 1つのセクション内で編集する、**Then** 他のセクションの構文木ノードは同一インスタンスが維持される
3. **Given** ブロック境界をまたぐ編集、**When** 再解析が行われる、**Then** 影響を受けるブロックとその隣接ブロックのみが再解析される

---

### ~~User Story 6 - テーブルの解析~~ (延期: 後続イテレーション)

> **注**: テーブル解析は MVP スコープ外。後続イテレーションで実装予定。
>
> テーブルは複雑な構文を持つため、基本的なパーサー機能が安定した後に追加する

---

### Edge Cases

- 空の文書はどうなるか？ → 空のドキュメントノードを持つ有効な構文木が生成される
- 巨大な単一行（数千文字）はどうなるか？ → パフォーマンス低下を最小限にしつつ解析を完了し、行の長さに関する警告は発しない（パーサーの責務外）
- BOM（Byte Order Mark）付きの UTF-8 ファイルはどうなるか？ → BOM はトリビアとして保持され、文書内容には影響しない
- 混在する改行コード（CR, LF, CRLF）はどうなるか？ → 各改行は元の形式で保持され、再構築時に正確に復元される
- 無限ループを引き起こす可能性のある再帰的構文はどうなるか？ → ネストレベル制限（デフォルト 100レベル、ParseOptions で可変）を設け、超過時はエラーノードを生成する
- include ディレクティブで参照されるファイルはどうなるか？ → パーサーは include ディレクティブを構文として認識するが、ファイルの実際の読み込みは行わない（外部処理として扱う）

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは AsciiDoc 文書を入力として受け取り、構文木（Concrete Syntax Tree）を出力しなければならない
- **FR-002**: AsciiDoc の文法は PEG（Parsing Expression Grammar）で定義し、参照仕様として文書化しなければならない。ただし、パーサーの実装は手書きとし、PEG 定義を読み込んでパーサーを生成するツール（パーサージェネレーター）は使用しない
- **FR-003**: 構文木は、空白、改行、コメントを含むすべてのソーステキスト要素を保持しなければならない（Lossless）
- **FR-004**: システムは構文木からソーステキストを完全に再構築できなければならない（Roundtrip）
- **FR-005**: システムは構文エラーを含む文書を解析し、エラー部分を特定しつつ、正常部分を最大限解析しなければならない（Error Recovery）
- **FR-006**: 構文木のすべてのノードは不変（Immutable）でなければならない
- **FR-007**: 構文木の変更操作は、元の構文木を変更せず、新しい構文木を返さなければならない
- **FR-008**: 各構文ノードは、ソース内での位置情報（開始位置、終了位置）を Unicode コードポイント単位で提供しなければならない（内部実装はバイト単位でも可）
- **FR-009**: システムは AsciiDoc の以下の要素を解析しなければならない（MVP スコープ）：
  - ドキュメントヘッダー（タイトル、著者行）
  - セクション（レベル0〜5）
  - ブロック（段落）
  - インライン要素（リンク）
  - コメント（行コメント、ブロックコメント）
  - **注**: リスト、テーブル、区切りブロック、書式マークアップ、マクロ、属性参照は後続イテレーションで実装
- **FR-010**: システムはエラー発生時に、エラーの位置と種類を示す診断情報を提供しなければならない
- **FR-011**: システムは部分的な再解析（Incremental Parsing）をサポートし、変更部分のみを効率的に再解析できなければならない

### Key Entities

**内部構文木（ユーザー非公開）**:
- **InternalNode（内部ノード）**: 不変の内部ノード。幅（Width）を持つが絶対位置を持たない。構造共有により効率的
- **InternalToken（内部トークン）**: 内部構文木の末端要素。テキスト内容と幅を保持

**外部構文木（ユーザー公開 API）**:
- **SyntaxNode（構文ノード）**: ユーザーが操作する外部ノード。親参照を持ち、位置は都度算出
- **SyntaxToken（構文トークン）**: 外部構文木の末端要素。位置情報を算出して提供
- **SyntaxTrivia（トリビア）**: 空白、改行、コメントなど、意味に影響しないがソース再構築に必要な要素

**AsciiDoc ドメインエンティティ（MVP スコープ）**:
- **Document（文書）**: AsciiDoc 文書全体を表すルートノード。ヘッダーとボディで構成される
- **Block（ブロック）**: 垂直に積み重なる構造単位。MVP では段落とセクションのみ
- **Inline（インライン要素）**: ブロック内に存在するテキストレベルの要素。MVP ではリンクのみ
- **Comment（コメント）**: 行コメントとブロックコメント

**診断**:
- **Diagnostic（診断情報）**: 構文エラーや警告の位置、種類、メッセージを保持するエンティティ

**パーサーオプション**:
- **ParseOptions（解析オプション）**: ネストレベル制限（デフォルト 100）などの解析動作を制御するオプション

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 構文木からソーステキストを再構築した結果が、100% の文書で元のテキストとバイト単位で一致する
- **SC-002**: 構文エラーを含む文書において、エラー箇所を除いた正常部分のトークンの 95% 以上が正しく解析される（測定単位: トークン数）
- **SC-003**: 構文木の不変性が保証され、同じノードへの複数の参照が安全に保持できる
- **SC-004**: MVP スコープとして以下の構文要素をサポートする：ドキュメントヘッダー（タイトル、著者行）、セクション、段落、リンク、コメント。拡充は後続イテレーションで実施

## Clarifications

### Session 2026-01-18

- Q: 位置情報のエンコーディング形式は？ → A: ユーザー向け API は Unicode コードポイント単位。内部実装はバイト単位でも可。
- Q: トリビア（空白・コメント）の付属モデルは？ → A: Roslyn モデル（トークンに先行/後続トリビアとして付属）を採用。

### Session 2026-01-19

- Q: SC-002 のエラー耐性解析の測定単位は？ → A: トークン数ベース（正しく解析されたトークン数 / 総トークン数）で測定。
- Q: SC-006 の構文要素サポート率の対象リストは？ → A: AsciiDoc Language Specification のセクション見出し（Blocks, Inline, Macros など）を列挙し、各セクションのサポート有無でカウント。
- Q: ネストレベル制限の具体値は？ → A: デフォルト 100レベル。ParseOptions で可変。
- Q: FR-002 の PEG 文法定義の用途は？ → A: 参照仕様としてドキュメント化する。パーサージェネレーターは使用せず、パーサーは手書きで実装する。PEG 定義は文法の正式な仕様として機能し、手書きパーサーの実装ガイドとなる。

### Session 2026-01-20（MVP スコープ縮小）

- Q: FR-009 と SC-006 のサポート範囲を縮小してよいか？ → A: はい。MVP では最小限の構文要素のみをサポートし、拡充は後続イテレーションに委ねる。
- **変更内容**:
  - FR-009: サポート範囲を「ドキュメントヘッダー（タイトル、著者行）、セクション、段落、リンク、コメント」に縮小
  - SC-006: 「90% サポート」の割合ベース目標を削除し、MVP スコープの明示的なリストに変更
  - User Story 1: リストを対象外に変更
  - User Story 3: 書式マークアップとマクロを対象外とし、リンクのみに縮小
  - User Story 6: テーブル解析を後続イテレーションに延期
- **理由**: 各カテゴリ（ブロック、インライン、メタデータ）で最低1種類をサポートすれば、パーサーのアーキテクチャと基本機能を検証可能。機能の拡充はアーキテクチャが安定した後に段階的に実施する方が効率的

### Session 2026-01-20（パフォーマンス数値目標削除）

- Q: パフォーマンスに関する数値目標を削除してよいか？ → A: はい。MVP では数値目標を設けない。
- **変更内容**:
  - SC-003（初回解析 500ms 以内）を削除
  - SC-004（増分再解析が全体の 10% 以下）を削除
  - 旧 SC-005 → SC-003、旧 SC-006 → SC-004 に繰り上げ
- **理由**: MVP 段階ではパフォーマンスの数値目標を設けることで実装の選択肢を狭めるリスクがある。パフォーマンス最適化は機能が安定した後のイテレーションで実施する

## Architecture Decisions

### 二層構文木モデル

.NET Roslyn の Red-Green Tree アーキテクチャに基づく二層構造を採用する。

**内部構文木（InternalSyntax）**:
- ユーザーからは直接アクセスできない
- 各ノードは**幅（Width）**を持つが、絶対的な開始位置は持たない
- 完全に不変（Immutable）で、構造共有により効率的なメモリ使用を実現
- 内部的にはバイト単位で幅を管理してもよい

**外部構文木（Syntax）**:
- ユーザーが操作する API レイヤー
- 開始位置・終了位置は、内部構文木の幅情報から**必要に応じて都度算出**される
- 位置情報は **Unicode コードポイント単位**で提供される
- 親ノードへの参照を保持し、木の上方向へのナビゲーションが可能

### トリビア付属モデル

Roslyn と同様に、トリビア（空白、改行、コメント）はトークンに付属する。

- **先行トリビア（Leading Trivia）**: トークンの直前にある空白・コメント
- **後続トリビア（Trailing Trivia）**: トークンの直後、次のトークンの先行トリビアの前までの空白・コメント
- 改行は通常、その行の最後のトークンの**後続トリビア**として扱う
- 次行のインデント（行頭空白）は次のトークンの**先行トリビア**として扱う

## Assumptions

- AsciiDoc の構文仕様は `submodules/asciidoc-lang` ディレクトリに含まれる内容に準拠する
- パーサーはファイル I/O を直接行わず、テキスト入力として文書を受け取る
- include ディレクティブの実際のファイル読み込みはパーサーの責務外（構文認識のみ）
- プリプロセッサディレクティブ（ifdef, ifndef, ifeval）は構文として認識するが、条件評価はパーサーの責務外
- UTF-8 エンコーディングを前提とし、他のエンコーディングは事前に変換されていると仮定する
- パフォーマンス要件は一般的な開発マシン（4コア以上の CPU、8GB 以上のメモリ）を想定する
