# Feature Specification: AsciiDoc パーサー

**Feature Branch**: `001-asciidoc-parser`
**Created**: 2026-01-18
**Status**: Draft
**Input**: User description: "AsciiDoctor パーサーを作成します。AsciiDoc の構文については submodules/asciidoc-lang 下を参照します。インタラクティブなエディタの基盤となるのに十分な能力とパフォーマンスを持ち、構文エラーがあっても正常な部分は最大限に解析します。空白やコメントも含め、構文木から元のテキストを完全に再現できるようにします。構文木は Immutable にし、既存の構文木に変更を加える場合は、新しい構文木を作成します。"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 基本的な AsciiDoc 文書の解析 (Priority: P1)

ユーザーは、セクション、段落、リストなどの基本的な構造を含む AsciiDoc 文書をパーサーに入力し、正しい構文木を取得する。構文木は元のテキストを完全に再現可能である。

**Why this priority**: これはパーサーの最も基本的な機能であり、他のすべての機能の土台となる。最小限の実用可能な製品を提供するために最優先で実装する必要がある。

**Independent Test**: 単一の AsciiDoc 文書を解析し、構文木から元のテキストを再構築することで、ラウンドトリップ検証ができる。

**Acceptance Scenarios**:

1. **Given** 有効な AsciiDoc 文書（セクションタイトル、段落、リスト）、**When** パーサーで解析する、**Then** 正しい階層構造を持つ構文木が生成され、元のテキストが完全に再現可能である
2. **Given** ドキュメントヘッダー（タイトル、著者、属性）を含む AsciiDoc 文書、**When** パーサーで解析する、**Then** ヘッダー情報が正しく解析され、属性が構文木内でアクセス可能である
3. **Given** 空白行で区切られた複数のブロック、**When** パーサーで解析する、**Then** 各ブロックが独立したノードとして認識され、空白行も構文木に保持される

---

### User Story 2 - エラー耐性解析 (Priority: P1)

ユーザーは、構文エラーを含む AsciiDoc 文書を解析しても、正常な部分は最大限に解析され、エディタで有用な情報を表示できる。

**Why this priority**: インタラクティブエディタでは、ユーザーが入力中の不完全な文書を常に解析する必要がある。エラー回復なしでは実用的なエディタ体験が提供できない。

**Independent Test**: 意図的に構文エラーを含む文書を解析し、エラー部分が特定され、正常部分が正しく解析されることを検証できる。

**Acceptance Scenarios**:

1. **Given** セクションタイトルのマーカーが不完全な AsciiDoc 文書、**When** パーサーで解析する、**Then** エラーノードが作成され、他の正常な部分は正しく解析される
2. **Given** 閉じられていないブロック区切りがある AsciiDoc 文書、**When** パーサーで解析する、**Then** 未閉のブロックがエラーとして記録され、後続の内容は最善の推測で解析される
3. **Given** 複数のエラーを含む AsciiDoc 文書、**When** パーサーで解析する、**Then** すべてのエラー位置が報告され、各エラー間の正常な部分は独立して解析される

---

### User Story 3 - インラインマークアップの解析 (Priority: P2)

ユーザーは、太字、斜体、等幅、リンク、マクロなどのインライン要素を含むテキストを解析し、各書式の開始・終了位置を正確に把握できる。

**Why this priority**: インライン要素の解析は文書の細部を構成し、エディタでのシンタックスハイライトや補完機能に不可欠である。ただし、ブロック構造が先に必要。

**Independent Test**: 様々なインラインマークアップを含む段落を解析し、各要素の種類と位置が正確に識別されることを検証できる。

**Acceptance Scenarios**:

1. **Given** 太字、斜体、等幅テキストを含む段落、**When** パーサーで解析する、**Then** 各書式要素の開始位置、終了位置、種類が構文木に記録される
2. **Given** ネストしたインライン書式（太字の中に斜体など）、**When** パーサーで解析する、**Then** 入れ子構造が正しく表現される
3. **Given** URL マクロ、相互参照、脚注マクロを含むテキスト、**When** パーサーで解析する、**Then** マクロの種類、ターゲット、属性が正しく解析される

---

### User Story 4 - 構文木の不変性とクエリ (Priority: P2)

開発者は、構文木を変更せずにクエリを行い、必要に応じて元の構文木を保持したまま新しい構文木を作成できる。

**Why this priority**: 不変性はエディタの undo/redo 機能、並行処理、キャッシングにおいて重要である。基本的な解析機能の後に実装可能。

**Independent Test**: 構文木に対して変更操作を行い、元の構文木が変更されず、新しい構文木が正しい変更を反映していることを検証できる。

**Acceptance Scenarios**:

1. **Given** 解析済みの構文木、**When** ノードを追加・削除・変更する操作を行う、**Then** 元の構文木は変更されず、変更を反映した新しい構文木が返される
2. **Given** 解析済みの構文木、**When** 特定の種類のノードをすべて検索するクエリを行う、**Then** 一致するノードのコレクションが返され、構文木は変更されない
3. **Given** 解析済みの構文木と、その構文木への参照を保持するコンポーネント、**When** 別のコンポーネントが構文木を「変更」する、**Then** 元の参照が指す構文木は影響を受けない

---

### User Story 5 - 増分解析 (Priority: P3)

ユーザーがエディタで文書の一部を編集したとき、パーサーは変更された部分のみを再解析し、変更されていない部分の解析結果を再利用する。

**Why this priority**: 大きな文書を編集する際のパフォーマンスを大幅に向上させる高度な機能。基本的な解析とエラー回復が安定してから実装する。

**Independent Test**: 大きな文書の一部を変更し、再解析時間が文書全体の解析時間より大幅に短いことを検証できる。

**Acceptance Scenarios**:

1. **Given** 1000行の AsciiDoc 文書と既存の構文木、**When** 10行目のみを編集する、**Then** 10行目を含むブロックのみが再解析され、他のブロックは再利用される
2. **Given** 複数のセクションを持つ文書、**When** 1つのセクション内で編集する、**Then** 他のセクションの構文木ノードは同一インスタンスが維持される
3. **Given** ブロック境界をまたぐ編集、**When** 再解析が行われる、**Then** 影響を受けるブロックとその隣接ブロックのみが再解析される

---

### User Story 6 - テーブルの解析 (Priority: P3)

ユーザーは、AsciiDoc のテーブル構文（区切り文字、列指定、ヘッダー行、セル書式など）を正しく解析できる。

**Why this priority**: テーブルは複雑な構文を持つが、基本的なブロック解析とインライン解析が実装された後に追加可能。

**Independent Test**: 様々なテーブル形式（基本、CSV、DSV、複雑なセル）を解析し、行・列・セルの構造が正しく認識されることを検証できる。

**Acceptance Scenarios**:

1. **Given** 基本的なテーブル（ヘッダー行あり、2列3行）、**When** パーサーで解析する、**Then** テーブル構造、ヘッダー、各セルの内容が正しく解析される
2. **Given** CSV 形式のデータを使用したテーブル、**When** パーサーで解析する、**Then** CSV フォーマットが認識され、データが正しくセルに分割される
3. **Given** セルの結合やスタイル指定を含むテーブル、**When** パーサーで解析する、**Then** セルのスパン情報とスタイル属性が構文木に記録される

---

### Edge Cases

- 空の文書はどうなるか？ → 空のドキュメントノードを持つ有効な構文木が生成される
- 巨大な単一行（数千文字）はどうなるか？ → パフォーマンス低下を最小限にしつつ解析を完了し、行の長さに関する警告は発しない（パーサーの責務外）
- BOM（Byte Order Mark）付きの UTF-8 ファイルはどうなるか？ → BOM はトリビアとして保持され、文書内容には影響しない
- 混在する改行コード（CR, LF, CRLF）はどうなるか？ → 各改行は元の形式で保持され、再構築時に正確に復元される
- 無限ループを引き起こす可能性のある再帰的構文はどうなるか？ → 適切なネストレベル制限を設け、超過時はエラーノードを生成する
- include ディレクティブで参照されるファイルはどうなるか？ → パーサーは include ディレクティブを構文として認識するが、ファイルの実際の読み込みは行わない（外部処理として扱う）

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは AsciiDoc 文書を入力として受け取り、構文木（Concrete Syntax Tree）を出力しなければならない
- **FR-002**: AsciiDoc の文法は PEG（Parsing Expression Grammar）で定義しなければならない
- **FR-003**: 構文木は、空白、改行、コメントを含むすべてのソーステキスト要素を保持しなければならない（Lossless）
- **FR-004**: システムは構文木からソーステキストを完全に再構築できなければならない（Roundtrip）
- **FR-005**: システムは構文エラーを含む文書を解析し、エラー部分を特定しつつ、正常部分を最大限解析しなければならない（Error Recovery）
- **FR-006**: 構文木のすべてのノードは不変（Immutable）でなければならない
- **FR-007**: 構文木の変更操作は、元の構文木を変更せず、新しい構文木を返さなければならない
- **FR-008**: 各構文ノードは、ソース内での位置情報（開始位置、終了位置）を Unicode コードポイント単位で提供しなければならない（内部実装はバイト単位でも可）
- **FR-009**: システムは AsciiDoc の以下の要素を解析しなければならない：
  - ドキュメントヘッダー（タイトル、著者行、リビジョン行、属性エントリ）
  - セクション（レベル0〜5）
  - ブロック（段落、区切りブロック、リテラルブロック、リストなど）
  - インライン要素（書式、マクロ、属性参照）
  - コメント（行コメント、ブロックコメント）
  - テーブル
- **FR-010**: システムはエラー発生時に、エラーの位置と種類を示す診断情報を提供しなければならない
- **FR-011**: システムは部分的な再解析（Incremental Parsing）をサポートし、変更部分のみを効率的に再解析できなければならない

### Key Entities

**内部構造（Green Tree - ユーザー非公開）**:
- **GreenNode（内部ノード）**: 不変の内部ノード。幅（Width）を持つが絶対位置を持たない。構造共有により効率的
- **GreenToken（内部トークン）**: 内部木の末端要素。テキスト内容と幅を保持

**外部構造（Red Tree - ユーザー公開 API）**:
- **SyntaxNode（構文ノード）**: ユーザーが操作する外部ノード。親参照を持ち、位置は都度算出
- **SyntaxToken（構文トークン）**: 外部木の末端要素。位置情報を算出して提供
- **SyntaxTrivia（トリビア）**: 空白、改行、コメントなど、意味に影響しないがソース再構築に必要な要素

**AsciiDoc ドメインエンティティ**:
- **Document（文書）**: AsciiDoc 文書全体を表すルートノード。ヘッダーとボディで構成される
- **Block（ブロック）**: 垂直に積み重なる構造単位。段落、セクション、リスト、テーブル、区切りブロックなど
- **Inline（インライン要素）**: ブロック内に存在するテキストレベルの要素。書式マークアップ、マクロ、属性参照

**診断**:
- **Diagnostic（診断情報）**: 構文エラーや警告の位置、種類、メッセージを保持するエンティティ

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 構文木からソーステキストを再構築した結果が、100% の文書で元のテキストとバイト単位で一致する
- **SC-002**: 構文エラーを含む文書において、エラー箇所を除いた正常部分の 95% 以上が正しく解析される
- **SC-003**: 一般的なサイズの文書（100KB 以下）の初回解析が 500 ミリ秒以内に完了する
- **SC-004**: 編集時の増分再解析が、全体再解析の 10% 以下の時間で完了する（変更が文書の 5% 以下の場合）
- **SC-005**: 構文木の不変性が保証され、同じノードへの複数の参照が安全に保持できる
- **SC-006**: submodules/asciidoc-lang の仕様に記載された主要な構文要素の 90% 以上をサポートする

## Clarifications

### Session 2026-01-18

- Q: 位置情報のエンコーディング形式は？ → A: ユーザー向け API は Unicode コードポイント単位。内部実装はバイト単位でも可。
- Q: トリビア（空白・コメント）の付属モデルは？ → A: Roslyn モデル（トークンに先行/後続トリビアとして付属）を採用。

## Architecture Decisions

### 赤緑木（Red-Green Tree）モデル

.NET Roslyn の赤緑木アーキテクチャを採用する。

**内部木（Green Tree）**:
- ユーザーからは直接アクセスできない
- 各ノードは**幅（Width）**を持つが、絶対的な開始位置は持たない
- 完全に不変（Immutable）で、構造共有により効率的なメモリ使用を実現
- 内部的にはバイト単位で幅を管理してもよい

**外部木（Red Tree / Syntax Tree）**:
- ユーザーが操作する API レイヤー
- 開始位置・終了位置は、内部木の幅情報から**必要に応じて都度算出**される
- 位置情報は **Unicode コードポイント単位**で提供される
- 親ノードへの参照を保持し、木の上方向へのナビゲーションが可能

### トリビア付属モデル

Roslyn と同様に、トリビア（空白、改行、コメント）はトークンに付属する。

- **先行トリビア（Leading Trivia）**: トークンの直前にある空白・コメント
- **後続トリビア（Trailing Trivia）**: トークンの直後、次のトークンの先行トリビアの前までの空白・コメント
- 改行は通常、その行の最後のトークンの**後続トリビア**として扱う
- 次行のインデント（行頭空白）は次のトークンの**先行トリビア**として扱う

## Assumptions

- AsciiDoc の構文仕様は `submodules/asciidoc-lang` ディレクトリに含まれる内容に準拠する
- パーサーはファイル I/O を直接行わず、テキスト入力として文書を受け取る
- include ディレクティブの実際のファイル読み込みはパーサーの責務外（構文認識のみ）
- プリプロセッサディレクティブ（ifdef, ifndef, ifeval）は構文として認識するが、条件評価はパーサーの責務外
- UTF-8 エンコーディングを前提とし、他のエンコーディングは事前に変換されていると仮定する
- パフォーマンス要件は一般的な開発マシン（4コア以上の CPU、8GB 以上のメモリ）を想定する
